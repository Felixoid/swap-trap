# Linux swap: некоторые мифы и их развенчание
За годы системного администрирования я видел несколько подходов к применению swap. Некоторые из них базируются на мифах, которые пришло время развенчать окончательно.

## Глоссарий
Память в ОС Linux - это оперативная память и дисковое пространство, которое для процессов представлено в виде виртуальной памяти.

Страницы памяти — это блок виртуальной памяти, как правило 4096 байт, который выделяется процессу или под кеши.

Swap - файл или раздел диска, который используется ядром в качестве расширения виртуальной памяти, когда RAM заканчивается, а процессы требуют ещё. Ядро имеет несколько параметров конфигурации, которые управляют процессом.

Дальнейшие действующие лица будут представлены в процессе

## Некоторые параметры управления памятью
- `vm.swappiness` - значение от 0 до 200 ([документация](https://github.com/torvalds/linux/commit/c843966c556d7370bb32e7319a6d164cb8c70ae2) для версий 5.8 и выше). Представляет собой относительную "цену" использования swap против RAM. Стоит отдельно отметить следующие значения:
    - 0 - swap  не используется, пока памяти достаточно (см kswapd)
    - 1..99 - swap стоит дороже RAM
    - 100 - стоимость swap и RAM одинаковы
    - 101..199 - swap стоит дешевле
    - 200 - RAM не используется, пока доступен swap
- `vm.watermark_scale_factor` - значения от 10 до 1000, задаётся в долях от 10000. Управляет агрессивностью kswapd. Это демон, который пробуждается ядром, чтобы очищать память. При бОльших значениях параметра он пробуждается раньше и очищает память агрессивнее. Для этого может быть выполнена одна из следующих операций:
    - очистить буфферы (buffer) и страниц памяти (page caches)
    - переместить в swap общие страницы (shared pages, память используемая несколькими процессами)
    - переместить в swap или отбросить страницы процессов

# Жизненный цикл памяти на сервере Linux
Итак, некий процесс запрашивает у ядра память. Ядро - это хитрая и экономная сущность. Сперва оно просто говорит процессу "на". Когда же процесс на самом деле начинает использовать эту память, ядро на самом деле выделяет страницы. Когда процесс требует всё больше и больше, ядро снова выделяет эту память. В фоне просыпается kswapd и выполняет очистку, но предположим, что память не бесконечна, и она заканчивается. То, что можно было, kswapd уже переместил в swap. Теперь в swap перемещаются все страницы, включая текущие активные.

Если процессы остановились и перестали жадничать, то мир продолжает работать. Если же нет, то просыпается специальный процесс OOM-killer. Лучше всего его предназначение описано этим комиксом:  
![oom-killer](http://turnoff.us/image/en/oom-killer.png)

Упрощённо это выглядит так.

# Мифы

## 1. vm.swappiness=0 выключает swap
Это самый распространённый миф, который больше всего мешает жить. Я не уверен, но кажется, что его первоисточник — статья в linuxhint [Understanding vm.swappiness](https://linuxhint.com/understanding_vm_swappiness/): `* 0: swap is disable`. Добавить к официальной документации мне нечего, я проверил на Debian Wheezy + 3.2 и на Debian Buster + 5.10. Swap используется, как только RAM заканчивается.

Debian 7:  


Debian 10:  
[![asciicast](https://asciinema.org/a/432367.svg)](https://asciinema.org/a/432367)

## 2. Страницы возвращаются из swap в RAM, если они активно используются
Ммммм... нет. Этот вывод сделан на основе исследования документации https://www.kernel.org/doc/gorman/html/understand/understand013.html + https://www.kernel.org/doc/gorman/html/understand/understand014.html + https://www.kernel.org/doc/gorman/html/understand/understand028.html. В ней рассматривается процесс swap_out, когда страницы перемещаются в swap. Но ни в документации, ни в коде swap_in не встречается. И, разумеется, подтверждается экспериментально. В скринкастах выше видно, что при добавлении на хост дополнительно памяти в режиме онлайн, страницы не перемещаются в RAM, хотя они и активно используются.

# Coming out
Почему я затеял эти эксперименты и начал копать в эту тему? Всё очень просто: я считаю, что swap **вреден**. Особенно на боевых серверах с нагрузкой от клиентов в реальном времени.

Из моего опыта, существует две "школы":

- Давайте начнём использовать swap и не умрём под пиковым потреблением памяти
- Давайте умрём от oom, а нагрузка переключится на другой хост.

Как видно из мифа номер 2, swap - это смертный приговор производительности. Как только какая-то страница важного приложения попадает в swap, начинается замедление. Проблема в том, что решение о перемещении страниц памяти в swap ядро принимает самостоятельно и процесс неуправляемый. Нельзя сказать: "это приложение критическое, не перемещай его в swap".

Я уверен, что есть случаи, когда использование swap оправдано. Например, я слышал такой аргумент:

— Допустим, в оперативку ты не влезаешь раз в квартал, а для того, чтобы её нарастить, надо менять вообще все, потому что и так установлен поддерживаемый железом максимум.

Абсолютно правдивое замечание. Старайтесь до такого не доводить.

### Код, использованный в статье
Логика программы для тестов достаточно проста. Сперва процесс запрашивает память, всё больше и больше. После каждого увеличения памяти байты в архиве сперва меняют порядок (reverse), а потом значения (битовое NOT, flip). Как только замечено значительное замедление, это значит начал использоваться swap и запускается бесконечный цикл с повторением reverse и flip.

Сам код можно посмотреть на [Github](https://github.com/Felixoid/swap-trap)
